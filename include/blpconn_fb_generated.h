// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BLPCONNFB_BLPCONN_FB_H_
#define FLATBUFFERS_GENERATED_BLPCONNFB_BLPCONN_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace BlpConn {
namespace FB {

struct DateTime;
struct DateTimeBuilder;

struct Value;
struct ValueBuilder;

struct HeadlineEconomicEvent;
struct HeadlineEconomicEventBuilder;

struct MacroReferenceData;
struct MacroReferenceDataBuilder;

struct MacroHeadlineEvent;
struct MacroHeadlineEventBuilder;

struct MacroCalendarEvent;
struct MacroCalendarEventBuilder;

struct HeadlineCalendarEvent;
struct HeadlineCalendarEventBuilder;

struct LogMessage;
struct LogMessageBuilder;

struct Main;
struct MainBuilder;

enum ReleaseStatus : uint8_t {
  ReleaseStatus_Unknown = 0,
  ReleaseStatus_Released = 1,
  ReleaseStatus_Scheduled = 2,
  ReleaseStatus_Another = 99,
  ReleaseStatus_MIN = ReleaseStatus_Unknown,
  ReleaseStatus_MAX = ReleaseStatus_Another
};

inline const ReleaseStatus (&EnumValuesReleaseStatus())[4] {
  static const ReleaseStatus values[] = {
    ReleaseStatus_Unknown,
    ReleaseStatus_Released,
    ReleaseStatus_Scheduled,
    ReleaseStatus_Another
  };
  return values;
}

inline const char *EnumNameReleaseStatus(ReleaseStatus e) {
  switch (e) {
    case ReleaseStatus_Unknown: return "Unknown";
    case ReleaseStatus_Released: return "Released";
    case ReleaseStatus_Scheduled: return "Scheduled";
    case ReleaseStatus_Another: return "Another";
    default: return "";
  }
}

enum ModuleType : uint8_t {
  ModuleType_ModuleUnknown = 0,
  ModuleType_ModuleSystem = 1,
  ModuleType_ModuleSession = 2,
  ModuleType_ModuleSubscription = 3,
  ModuleType_ModuleService = 4,
  ModuleType_ModuleHearbeat = 5,
  ModuleType_ModuleAnother = 99,
  ModuleType_MIN = ModuleType_ModuleUnknown,
  ModuleType_MAX = ModuleType_ModuleAnother
};

inline const ModuleType (&EnumValuesModuleType())[7] {
  static const ModuleType values[] = {
    ModuleType_ModuleUnknown,
    ModuleType_ModuleSystem,
    ModuleType_ModuleSession,
    ModuleType_ModuleSubscription,
    ModuleType_ModuleService,
    ModuleType_ModuleHearbeat,
    ModuleType_ModuleAnother
  };
  return values;
}

inline const char *EnumNameModuleType(ModuleType e) {
  switch (e) {
    case ModuleType_ModuleUnknown: return "ModuleUnknown";
    case ModuleType_ModuleSystem: return "ModuleSystem";
    case ModuleType_ModuleSession: return "ModuleSession";
    case ModuleType_ModuleSubscription: return "ModuleSubscription";
    case ModuleType_ModuleService: return "ModuleService";
    case ModuleType_ModuleHearbeat: return "ModuleHearbeat";
    case ModuleType_ModuleAnother: return "ModuleAnother";
    default: return "";
  }
}

enum SubscriptionStatusType : uint8_t {
  SubscriptionStatusType_SubscriptionUnknown = 0,
  SubscriptionStatusType_SubscriptionStarted = 1,
  SubscriptionStatusType_SubscriptionStreamsActivated = 2,
  SubscriptionStatusType_SubscriptionTerminated = 3,
  SubscriptionStatusType_SubscriptionSuccess = 4,
  SubscriptionStatusType_SubscriptionFailure = 5,
  SubscriptionStatusType_SubscriptionAnother = 99,
  SubscriptionStatusType_MIN = SubscriptionStatusType_SubscriptionUnknown,
  SubscriptionStatusType_MAX = SubscriptionStatusType_SubscriptionAnother
};

inline const SubscriptionStatusType (&EnumValuesSubscriptionStatusType())[7] {
  static const SubscriptionStatusType values[] = {
    SubscriptionStatusType_SubscriptionUnknown,
    SubscriptionStatusType_SubscriptionStarted,
    SubscriptionStatusType_SubscriptionStreamsActivated,
    SubscriptionStatusType_SubscriptionTerminated,
    SubscriptionStatusType_SubscriptionSuccess,
    SubscriptionStatusType_SubscriptionFailure,
    SubscriptionStatusType_SubscriptionAnother
  };
  return values;
}

inline const char *EnumNameSubscriptionStatusType(SubscriptionStatusType e) {
  switch (e) {
    case SubscriptionStatusType_SubscriptionUnknown: return "SubscriptionUnknown";
    case SubscriptionStatusType_SubscriptionStarted: return "SubscriptionStarted";
    case SubscriptionStatusType_SubscriptionStreamsActivated: return "SubscriptionStreamsActivated";
    case SubscriptionStatusType_SubscriptionTerminated: return "SubscriptionTerminated";
    case SubscriptionStatusType_SubscriptionSuccess: return "SubscriptionSuccess";
    case SubscriptionStatusType_SubscriptionFailure: return "SubscriptionFailure";
    case SubscriptionStatusType_SubscriptionAnother: return "SubscriptionAnother";
    default: return "";
  }
}

enum ServiceStatusType : uint8_t {
  ServiceStatusType_ServiceUnknown = 0,
  ServiceStatusType_ServiceOpened = 1,
  ServiceStatusType_ServiceClosed = 2,
  ServiceStatusType_ServiceFailure = 3,
  ServiceStatusType_ServiceAnother = 99,
  ServiceStatusType_MIN = ServiceStatusType_ServiceUnknown,
  ServiceStatusType_MAX = ServiceStatusType_ServiceAnother
};

inline const ServiceStatusType (&EnumValuesServiceStatusType())[5] {
  static const ServiceStatusType values[] = {
    ServiceStatusType_ServiceUnknown,
    ServiceStatusType_ServiceOpened,
    ServiceStatusType_ServiceClosed,
    ServiceStatusType_ServiceFailure,
    ServiceStatusType_ServiceAnother
  };
  return values;
}

inline const char *EnumNameServiceStatusType(ServiceStatusType e) {
  switch (e) {
    case ServiceStatusType_ServiceUnknown: return "ServiceUnknown";
    case ServiceStatusType_ServiceOpened: return "ServiceOpened";
    case ServiceStatusType_ServiceClosed: return "ServiceClosed";
    case ServiceStatusType_ServiceFailure: return "ServiceFailure";
    case ServiceStatusType_ServiceAnother: return "ServiceAnother";
    default: return "";
  }
}

enum SessionStatusType : uint8_t {
  SessionStatusType_SessionUnknown = 0,
  SessionStatusType_SessionConnectionUp = 1,
  SessionStatusType_SessionStarted = 2,
  SessionStatusType_SessionConnectionDown = 3,
  SessionStatusType_SessionTerminated = 4,
  SessionStatusType_SessionInvalidOptions = 5,
  SessionStatusType_SessionFailure = 6,
  SessionStatusType_SessionAnother = 99,
  SessionStatusType_MIN = SessionStatusType_SessionUnknown,
  SessionStatusType_MAX = SessionStatusType_SessionAnother
};

inline const SessionStatusType (&EnumValuesSessionStatusType())[8] {
  static const SessionStatusType values[] = {
    SessionStatusType_SessionUnknown,
    SessionStatusType_SessionConnectionUp,
    SessionStatusType_SessionStarted,
    SessionStatusType_SessionConnectionDown,
    SessionStatusType_SessionTerminated,
    SessionStatusType_SessionInvalidOptions,
    SessionStatusType_SessionFailure,
    SessionStatusType_SessionAnother
  };
  return values;
}

inline const char *EnumNameSessionStatusType(SessionStatusType e) {
  switch (e) {
    case SessionStatusType_SessionUnknown: return "SessionUnknown";
    case SessionStatusType_SessionConnectionUp: return "SessionConnectionUp";
    case SessionStatusType_SessionStarted: return "SessionStarted";
    case SessionStatusType_SessionConnectionDown: return "SessionConnectionDown";
    case SessionStatusType_SessionTerminated: return "SessionTerminated";
    case SessionStatusType_SessionInvalidOptions: return "SessionInvalidOptions";
    case SessionStatusType_SessionFailure: return "SessionFailure";
    case SessionStatusType_SessionAnother: return "SessionAnother";
    default: return "";
  }
}

enum EventSubType : uint8_t {
  EventSubType_Unknown = 0,
  EventSubType_New = 1,
  EventSubType_Update = 2,
  EventSubType_Unitpaint = 3,
  EventSubType_Delete = 4,
  EventSubType_Another = 99,
  EventSubType_MIN = EventSubType_Unknown,
  EventSubType_MAX = EventSubType_Another
};

inline const EventSubType (&EnumValuesEventSubType())[6] {
  static const EventSubType values[] = {
    EventSubType_Unknown,
    EventSubType_New,
    EventSubType_Update,
    EventSubType_Unitpaint,
    EventSubType_Delete,
    EventSubType_Another
  };
  return values;
}

inline const char *EnumNameEventSubType(EventSubType e) {
  switch (e) {
    case EventSubType_Unknown: return "Unknown";
    case EventSubType_New: return "New";
    case EventSubType_Update: return "Update";
    case EventSubType_Unitpaint: return "Unitpaint";
    case EventSubType_Delete: return "Delete";
    case EventSubType_Another: return "Another";
    default: return "";
  }
}

enum EventType : uint8_t {
  EventType_Unknown = 0,
  EventType_Actual = 1,
  EventType_Revision = 2,
  EventType_Estimate = 3,
  EventType_Calendar = 4,
  EventType_Another = 99,
  EventType_MIN = EventType_Unknown,
  EventType_MAX = EventType_Another
};

inline const EventType (&EnumValuesEventType())[6] {
  static const EventType values[] = {
    EventType_Unknown,
    EventType_Actual,
    EventType_Revision,
    EventType_Estimate,
    EventType_Calendar,
    EventType_Another
  };
  return values;
}

inline const char *EnumNameEventType(EventType e) {
  switch (e) {
    case EventType_Unknown: return "Unknown";
    case EventType_Actual: return "Actual";
    case EventType_Revision: return "Revision";
    case EventType_Estimate: return "Estimate";
    case EventType_Calendar: return "Calendar";
    case EventType_Another: return "Another";
    default: return "";
  }
}

enum SessionType : uint8_t {
  SessionType_Unknowk = 0,
  SessionType_SessionConnectionUp = 1,
  SessionType_SessionStarted = 2,
  SessionType_SessionConnectionDown = 3,
  SessionType_SessionTerminated = 4,
  SessionType_Another = 99,
  SessionType_MIN = SessionType_Unknowk,
  SessionType_MAX = SessionType_Another
};

inline const SessionType (&EnumValuesSessionType())[6] {
  static const SessionType values[] = {
    SessionType_Unknowk,
    SessionType_SessionConnectionUp,
    SessionType_SessionStarted,
    SessionType_SessionConnectionDown,
    SessionType_SessionTerminated,
    SessionType_Another
  };
  return values;
}

inline const char *EnumNameSessionType(SessionType e) {
  switch (e) {
    case SessionType_Unknowk: return "Unknowk";
    case SessionType_SessionConnectionUp: return "SessionConnectionUp";
    case SessionType_SessionStarted: return "SessionStarted";
    case SessionType_SessionConnectionDown: return "SessionConnectionDown";
    case SessionType_SessionTerminated: return "SessionTerminated";
    case SessionType_Another: return "Another";
    default: return "";
  }
}

enum Message : uint8_t {
  Message_NONE = 0,
  Message_HeadlineEconomicEvent = 1,
  Message_HeadlineCalendarEvent = 2,
  Message_MacroReferenceData = 3,
  Message_MacroHeadlineEvent = 4,
  Message_MacroCalendarEvent = 5,
  Message_LogMessage = 6,
  Message_MIN = Message_NONE,
  Message_MAX = Message_LogMessage
};

inline const Message (&EnumValuesMessage())[7] {
  static const Message values[] = {
    Message_NONE,
    Message_HeadlineEconomicEvent,
    Message_HeadlineCalendarEvent,
    Message_MacroReferenceData,
    Message_MacroHeadlineEvent,
    Message_MacroCalendarEvent,
    Message_LogMessage
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[8] = {
    "NONE",
    "HeadlineEconomicEvent",
    "HeadlineCalendarEvent",
    "MacroReferenceData",
    "MacroHeadlineEvent",
    "MacroCalendarEvent",
    "LogMessage",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (::flatbuffers::IsOutRange(e, Message_NONE, Message_LogMessage)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<BlpConn::FB::HeadlineEconomicEvent> {
  static const Message enum_value = Message_HeadlineEconomicEvent;
};

template<> struct MessageTraits<BlpConn::FB::HeadlineCalendarEvent> {
  static const Message enum_value = Message_HeadlineCalendarEvent;
};

template<> struct MessageTraits<BlpConn::FB::MacroReferenceData> {
  static const Message enum_value = Message_MacroReferenceData;
};

template<> struct MessageTraits<BlpConn::FB::MacroHeadlineEvent> {
  static const Message enum_value = Message_MacroHeadlineEvent;
};

template<> struct MessageTraits<BlpConn::FB::MacroCalendarEvent> {
  static const Message enum_value = Message_MacroCalendarEvent;
};

template<> struct MessageTraits<BlpConn::FB::LogMessage> {
  static const Message enum_value = Message_LogMessage;
};

bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct DateTime FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DateTimeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MICROS = 4,
    VT_OFFSET = 6
  };
  uint64_t micros() const {
    return GetField<uint64_t>(VT_MICROS, 0);
  }
  int16_t offset() const {
    return GetField<int16_t>(VT_OFFSET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MICROS, 8) &&
           VerifyField<int16_t>(verifier, VT_OFFSET, 2) &&
           verifier.EndTable();
  }
};

struct DateTimeBuilder {
  typedef DateTime Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_micros(uint64_t micros) {
    fbb_.AddElement<uint64_t>(DateTime::VT_MICROS, micros, 0);
  }
  void add_offset(int16_t offset) {
    fbb_.AddElement<int16_t>(DateTime::VT_OFFSET, offset, 0);
  }
  explicit DateTimeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DateTime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DateTime>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DateTime> CreateDateTime(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t micros = 0,
    int16_t offset = 0) {
  DateTimeBuilder builder_(_fbb);
  builder_.add_micros(micros);
  builder_.add_offset(offset);
  return builder_.Finish();
}

struct Value FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBER = 4,
    VT_VALUE = 6,
    VT_LOW = 8,
    VT_HIGH = 10,
    VT_MEDIAN = 12,
    VT_AVERAGE = 14,
    VT_STANDARD_DEVIATION = 16
  };
  double number() const {
    return GetField<double>(VT_NUMBER, 0.0);
  }
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  double low() const {
    return GetField<double>(VT_LOW, 0.0);
  }
  double high() const {
    return GetField<double>(VT_HIGH, 0.0);
  }
  double median() const {
    return GetField<double>(VT_MEDIAN, 0.0);
  }
  double average() const {
    return GetField<double>(VT_AVERAGE, 0.0);
  }
  double standard_deviation() const {
    return GetField<double>(VT_STANDARD_DEVIATION, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_NUMBER, 8) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           VerifyField<double>(verifier, VT_LOW, 8) &&
           VerifyField<double>(verifier, VT_HIGH, 8) &&
           VerifyField<double>(verifier, VT_MEDIAN, 8) &&
           VerifyField<double>(verifier, VT_AVERAGE, 8) &&
           VerifyField<double>(verifier, VT_STANDARD_DEVIATION, 8) &&
           verifier.EndTable();
  }
};

struct ValueBuilder {
  typedef Value Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_number(double number) {
    fbb_.AddElement<double>(Value::VT_NUMBER, number, 0.0);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(Value::VT_VALUE, value, 0.0);
  }
  void add_low(double low) {
    fbb_.AddElement<double>(Value::VT_LOW, low, 0.0);
  }
  void add_high(double high) {
    fbb_.AddElement<double>(Value::VT_HIGH, high, 0.0);
  }
  void add_median(double median) {
    fbb_.AddElement<double>(Value::VT_MEDIAN, median, 0.0);
  }
  void add_average(double average) {
    fbb_.AddElement<double>(Value::VT_AVERAGE, average, 0.0);
  }
  void add_standard_deviation(double standard_deviation) {
    fbb_.AddElement<double>(Value::VT_STANDARD_DEVIATION, standard_deviation, 0.0);
  }
  explicit ValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Value>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Value> CreateValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double number = 0.0,
    double value = 0.0,
    double low = 0.0,
    double high = 0.0,
    double median = 0.0,
    double average = 0.0,
    double standard_deviation = 0.0) {
  ValueBuilder builder_(_fbb);
  builder_.add_standard_deviation(standard_deviation);
  builder_.add_average(average);
  builder_.add_median(median);
  builder_.add_high(high);
  builder_.add_low(low);
  builder_.add_value(value);
  builder_.add_number(number);
  return builder_.Finish();
}

struct HeadlineEconomicEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeadlineEconomicEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_BB_GLOBAL = 4,
    VT_PARSEKYABLE_DES = 6,
    VT_DESCRIPTION = 8,
    VT_EVENT_TYPE = 10,
    VT_EVENT_SUBTYPE = 12,
    VT_EVENT_ID = 14,
    VT_OBSERVATION_PERIOD = 16,
    VT_RELEASE_START_DT = 18,
    VT_RELEASE_END_DT = 20,
    VT_VALUE = 22,
    VT_PRIOR_VALUE = 24,
    VT_PRIOR_EVENT_ID = 26,
    VT_PRIOR_OBSERVATION_PERIOD = 28,
    VT_PRIOR_ECONOMIC_RELEASE_START_DT = 30,
    VT_PRIOR_ECONOMIC_RELEASE_END_DT = 32
  };
  const ::flatbuffers::String *id_bb_global() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_BB_GLOBAL);
  }
  const ::flatbuffers::String *parsekyable_des() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARSEKYABLE_DES);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  BlpConn::FB::EventType event_type() const {
    return static_cast<BlpConn::FB::EventType>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  BlpConn::FB::EventSubType event_subtype() const {
    return static_cast<BlpConn::FB::EventSubType>(GetField<uint8_t>(VT_EVENT_SUBTYPE, 0));
  }
  uint64_t event_id() const {
    return GetField<uint64_t>(VT_EVENT_ID, 0);
  }
  const ::flatbuffers::String *observation_period() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBSERVATION_PERIOD);
  }
  const BlpConn::FB::DateTime *release_start_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_RELEASE_START_DT);
  }
  const BlpConn::FB::DateTime *release_end_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_RELEASE_END_DT);
  }
  const BlpConn::FB::Value *value() const {
    return GetPointer<const BlpConn::FB::Value *>(VT_VALUE);
  }
  const BlpConn::FB::Value *prior_value() const {
    return GetPointer<const BlpConn::FB::Value *>(VT_PRIOR_VALUE);
  }
  int32_t prior_event_id() const {
    return GetField<int32_t>(VT_PRIOR_EVENT_ID, 0);
  }
  const ::flatbuffers::String *prior_observation_period() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRIOR_OBSERVATION_PERIOD);
  }
  const BlpConn::FB::DateTime *prior_economic_release_start_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_PRIOR_ECONOMIC_RELEASE_START_DT);
  }
  const BlpConn::FB::DateTime *prior_economic_release_end_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_PRIOR_ECONOMIC_RELEASE_END_DT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID_BB_GLOBAL) &&
           verifier.VerifyString(id_bb_global()) &&
           VerifyOffsetRequired(verifier, VT_PARSEKYABLE_DES) &&
           verifier.VerifyString(parsekyable_des()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_SUBTYPE, 1) &&
           VerifyField<uint64_t>(verifier, VT_EVENT_ID, 8) &&
           VerifyOffset(verifier, VT_OBSERVATION_PERIOD) &&
           verifier.VerifyString(observation_period()) &&
           VerifyOffset(verifier, VT_RELEASE_START_DT) &&
           verifier.VerifyTable(release_start_dt()) &&
           VerifyOffset(verifier, VT_RELEASE_END_DT) &&
           verifier.VerifyTable(release_end_dt()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyOffset(verifier, VT_PRIOR_VALUE) &&
           verifier.VerifyTable(prior_value()) &&
           VerifyField<int32_t>(verifier, VT_PRIOR_EVENT_ID, 4) &&
           VerifyOffset(verifier, VT_PRIOR_OBSERVATION_PERIOD) &&
           verifier.VerifyString(prior_observation_period()) &&
           VerifyOffset(verifier, VT_PRIOR_ECONOMIC_RELEASE_START_DT) &&
           verifier.VerifyTable(prior_economic_release_start_dt()) &&
           VerifyOffset(verifier, VT_PRIOR_ECONOMIC_RELEASE_END_DT) &&
           verifier.VerifyTable(prior_economic_release_end_dt()) &&
           verifier.EndTable();
  }
};

struct HeadlineEconomicEventBuilder {
  typedef HeadlineEconomicEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id_bb_global(::flatbuffers::Offset<::flatbuffers::String> id_bb_global) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_ID_BB_GLOBAL, id_bb_global);
  }
  void add_parsekyable_des(::flatbuffers::Offset<::flatbuffers::String> parsekyable_des) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_PARSEKYABLE_DES, parsekyable_des);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_DESCRIPTION, description);
  }
  void add_event_type(BlpConn::FB::EventType event_type) {
    fbb_.AddElement<uint8_t>(HeadlineEconomicEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event_subtype(BlpConn::FB::EventSubType event_subtype) {
    fbb_.AddElement<uint8_t>(HeadlineEconomicEvent::VT_EVENT_SUBTYPE, static_cast<uint8_t>(event_subtype), 0);
  }
  void add_event_id(uint64_t event_id) {
    fbb_.AddElement<uint64_t>(HeadlineEconomicEvent::VT_EVENT_ID, event_id, 0);
  }
  void add_observation_period(::flatbuffers::Offset<::flatbuffers::String> observation_period) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_OBSERVATION_PERIOD, observation_period);
  }
  void add_release_start_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_RELEASE_START_DT, release_start_dt);
  }
  void add_release_end_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_RELEASE_END_DT, release_end_dt);
  }
  void add_value(::flatbuffers::Offset<BlpConn::FB::Value> value) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_VALUE, value);
  }
  void add_prior_value(::flatbuffers::Offset<BlpConn::FB::Value> prior_value) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_PRIOR_VALUE, prior_value);
  }
  void add_prior_event_id(int32_t prior_event_id) {
    fbb_.AddElement<int32_t>(HeadlineEconomicEvent::VT_PRIOR_EVENT_ID, prior_event_id, 0);
  }
  void add_prior_observation_period(::flatbuffers::Offset<::flatbuffers::String> prior_observation_period) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_PRIOR_OBSERVATION_PERIOD, prior_observation_period);
  }
  void add_prior_economic_release_start_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_start_dt) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_PRIOR_ECONOMIC_RELEASE_START_DT, prior_economic_release_start_dt);
  }
  void add_prior_economic_release_end_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_end_dt) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_PRIOR_ECONOMIC_RELEASE_END_DT, prior_economic_release_end_dt);
  }
  explicit HeadlineEconomicEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HeadlineEconomicEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HeadlineEconomicEvent>(end);
    fbb_.Required(o, HeadlineEconomicEvent::VT_ID_BB_GLOBAL);
    fbb_.Required(o, HeadlineEconomicEvent::VT_PARSEKYABLE_DES);
    return o;
  }
};

inline ::flatbuffers::Offset<HeadlineEconomicEvent> CreateHeadlineEconomicEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id_bb_global = 0,
    ::flatbuffers::Offset<::flatbuffers::String> parsekyable_des = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    BlpConn::FB::EventType event_type = BlpConn::FB::EventType_Unknown,
    BlpConn::FB::EventSubType event_subtype = BlpConn::FB::EventSubType_Unknown,
    uint64_t event_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> observation_period = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::Value> value = 0,
    ::flatbuffers::Offset<BlpConn::FB::Value> prior_value = 0,
    int32_t prior_event_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> prior_observation_period = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_end_dt = 0) {
  HeadlineEconomicEventBuilder builder_(_fbb);
  builder_.add_event_id(event_id);
  builder_.add_prior_economic_release_end_dt(prior_economic_release_end_dt);
  builder_.add_prior_economic_release_start_dt(prior_economic_release_start_dt);
  builder_.add_prior_observation_period(prior_observation_period);
  builder_.add_prior_event_id(prior_event_id);
  builder_.add_prior_value(prior_value);
  builder_.add_value(value);
  builder_.add_release_end_dt(release_end_dt);
  builder_.add_release_start_dt(release_start_dt);
  builder_.add_observation_period(observation_period);
  builder_.add_description(description);
  builder_.add_parsekyable_des(parsekyable_des);
  builder_.add_id_bb_global(id_bb_global);
  builder_.add_event_subtype(event_subtype);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HeadlineEconomicEvent> CreateHeadlineEconomicEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id_bb_global = nullptr,
    const char *parsekyable_des = nullptr,
    const char *description = nullptr,
    BlpConn::FB::EventType event_type = BlpConn::FB::EventType_Unknown,
    BlpConn::FB::EventSubType event_subtype = BlpConn::FB::EventSubType_Unknown,
    uint64_t event_id = 0,
    const char *observation_period = nullptr,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::Value> value = 0,
    ::flatbuffers::Offset<BlpConn::FB::Value> prior_value = 0,
    int32_t prior_event_id = 0,
    const char *prior_observation_period = nullptr,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_end_dt = 0) {
  auto id_bb_global__ = id_bb_global ? _fbb.CreateString(id_bb_global) : 0;
  auto parsekyable_des__ = parsekyable_des ? _fbb.CreateString(parsekyable_des) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto observation_period__ = observation_period ? _fbb.CreateString(observation_period) : 0;
  auto prior_observation_period__ = prior_observation_period ? _fbb.CreateString(prior_observation_period) : 0;
  return BlpConn::FB::CreateHeadlineEconomicEvent(
      _fbb,
      id_bb_global__,
      parsekyable_des__,
      description__,
      event_type,
      event_subtype,
      event_id,
      observation_period__,
      release_start_dt,
      release_end_dt,
      value,
      prior_value,
      prior_event_id,
      prior_observation_period__,
      prior_economic_release_start_dt,
      prior_economic_release_end_dt);
}

struct MacroReferenceData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MacroReferenceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CORR_ID = 4,
    VT_ID_BB_GLOBAL = 6,
    VT_PARSEKYABLE_DES = 8,
    VT_DESCRIPTION = 10,
    VT_INDX_FREQ = 12,
    VT_INDX_UNITS = 14,
    VT_COUNTRY_ISO = 16,
    VT_INDX_SOURCE = 18,
    VT_SEASONALITY_TRANSFORMATION = 20
  };
  int64_t corr_id() const {
    return GetField<int64_t>(VT_CORR_ID, 0);
  }
  const ::flatbuffers::String *id_bb_global() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_BB_GLOBAL);
  }
  const ::flatbuffers::String *parsekyable_des() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARSEKYABLE_DES);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::String *indx_freq() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INDX_FREQ);
  }
  const ::flatbuffers::String *indx_units() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INDX_UNITS);
  }
  const ::flatbuffers::String *country_iso() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTRY_ISO);
  }
  const ::flatbuffers::String *indx_source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INDX_SOURCE);
  }
  const ::flatbuffers::String *seasonality_transformation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEASONALITY_TRANSFORMATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CORR_ID, 8) &&
           VerifyOffsetRequired(verifier, VT_ID_BB_GLOBAL) &&
           verifier.VerifyString(id_bb_global()) &&
           VerifyOffsetRequired(verifier, VT_PARSEKYABLE_DES) &&
           verifier.VerifyString(parsekyable_des()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_INDX_FREQ) &&
           verifier.VerifyString(indx_freq()) &&
           VerifyOffset(verifier, VT_INDX_UNITS) &&
           verifier.VerifyString(indx_units()) &&
           VerifyOffset(verifier, VT_COUNTRY_ISO) &&
           verifier.VerifyString(country_iso()) &&
           VerifyOffset(verifier, VT_INDX_SOURCE) &&
           verifier.VerifyString(indx_source()) &&
           VerifyOffset(verifier, VT_SEASONALITY_TRANSFORMATION) &&
           verifier.VerifyString(seasonality_transformation()) &&
           verifier.EndTable();
  }
};

struct MacroReferenceDataBuilder {
  typedef MacroReferenceData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_corr_id(int64_t corr_id) {
    fbb_.AddElement<int64_t>(MacroReferenceData::VT_CORR_ID, corr_id, 0);
  }
  void add_id_bb_global(::flatbuffers::Offset<::flatbuffers::String> id_bb_global) {
    fbb_.AddOffset(MacroReferenceData::VT_ID_BB_GLOBAL, id_bb_global);
  }
  void add_parsekyable_des(::flatbuffers::Offset<::flatbuffers::String> parsekyable_des) {
    fbb_.AddOffset(MacroReferenceData::VT_PARSEKYABLE_DES, parsekyable_des);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(MacroReferenceData::VT_DESCRIPTION, description);
  }
  void add_indx_freq(::flatbuffers::Offset<::flatbuffers::String> indx_freq) {
    fbb_.AddOffset(MacroReferenceData::VT_INDX_FREQ, indx_freq);
  }
  void add_indx_units(::flatbuffers::Offset<::flatbuffers::String> indx_units) {
    fbb_.AddOffset(MacroReferenceData::VT_INDX_UNITS, indx_units);
  }
  void add_country_iso(::flatbuffers::Offset<::flatbuffers::String> country_iso) {
    fbb_.AddOffset(MacroReferenceData::VT_COUNTRY_ISO, country_iso);
  }
  void add_indx_source(::flatbuffers::Offset<::flatbuffers::String> indx_source) {
    fbb_.AddOffset(MacroReferenceData::VT_INDX_SOURCE, indx_source);
  }
  void add_seasonality_transformation(::flatbuffers::Offset<::flatbuffers::String> seasonality_transformation) {
    fbb_.AddOffset(MacroReferenceData::VT_SEASONALITY_TRANSFORMATION, seasonality_transformation);
  }
  explicit MacroReferenceDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MacroReferenceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MacroReferenceData>(end);
    fbb_.Required(o, MacroReferenceData::VT_ID_BB_GLOBAL);
    fbb_.Required(o, MacroReferenceData::VT_PARSEKYABLE_DES);
    return o;
  }
};

inline ::flatbuffers::Offset<MacroReferenceData> CreateMacroReferenceData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t corr_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> id_bb_global = 0,
    ::flatbuffers::Offset<::flatbuffers::String> parsekyable_des = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> indx_freq = 0,
    ::flatbuffers::Offset<::flatbuffers::String> indx_units = 0,
    ::flatbuffers::Offset<::flatbuffers::String> country_iso = 0,
    ::flatbuffers::Offset<::flatbuffers::String> indx_source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> seasonality_transformation = 0) {
  MacroReferenceDataBuilder builder_(_fbb);
  builder_.add_corr_id(corr_id);
  builder_.add_seasonality_transformation(seasonality_transformation);
  builder_.add_indx_source(indx_source);
  builder_.add_country_iso(country_iso);
  builder_.add_indx_units(indx_units);
  builder_.add_indx_freq(indx_freq);
  builder_.add_description(description);
  builder_.add_parsekyable_des(parsekyable_des);
  builder_.add_id_bb_global(id_bb_global);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MacroReferenceData> CreateMacroReferenceDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t corr_id = 0,
    const char *id_bb_global = nullptr,
    const char *parsekyable_des = nullptr,
    const char *description = nullptr,
    const char *indx_freq = nullptr,
    const char *indx_units = nullptr,
    const char *country_iso = nullptr,
    const char *indx_source = nullptr,
    const char *seasonality_transformation = nullptr) {
  auto id_bb_global__ = id_bb_global ? _fbb.CreateString(id_bb_global) : 0;
  auto parsekyable_des__ = parsekyable_des ? _fbb.CreateString(parsekyable_des) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto indx_freq__ = indx_freq ? _fbb.CreateString(indx_freq) : 0;
  auto indx_units__ = indx_units ? _fbb.CreateString(indx_units) : 0;
  auto country_iso__ = country_iso ? _fbb.CreateString(country_iso) : 0;
  auto indx_source__ = indx_source ? _fbb.CreateString(indx_source) : 0;
  auto seasonality_transformation__ = seasonality_transformation ? _fbb.CreateString(seasonality_transformation) : 0;
  return BlpConn::FB::CreateMacroReferenceData(
      _fbb,
      corr_id,
      id_bb_global__,
      parsekyable_des__,
      description__,
      indx_freq__,
      indx_units__,
      country_iso__,
      indx_source__,
      seasonality_transformation__);
}

struct MacroHeadlineEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MacroHeadlineEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CORR_ID = 4,
    VT_EVENT_TYPE = 6,
    VT_EVENT_SUBTYPE = 8,
    VT_EVENT_ID = 10,
    VT_OBSERVATION_PERIOD = 12,
    VT_RELEASE_START_DT = 14,
    VT_RELEASE_END_DT = 16,
    VT_PRIOR_EVENT_ID = 18,
    VT_PRIOR_OBSERVATION_PERIOD = 20,
    VT_PRIOR_ECONOMIC_RELEASE_START_DT = 22,
    VT_PRIOR_ECONOMIC_RELEASE_END_DT = 24,
    VT_VALUE = 26
  };
  int64_t corr_id() const {
    return GetField<int64_t>(VT_CORR_ID, 0);
  }
  BlpConn::FB::EventType event_type() const {
    return static_cast<BlpConn::FB::EventType>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  BlpConn::FB::EventSubType event_subtype() const {
    return static_cast<BlpConn::FB::EventSubType>(GetField<uint8_t>(VT_EVENT_SUBTYPE, 0));
  }
  int32_t event_id() const {
    return GetField<int32_t>(VT_EVENT_ID, 0);
  }
  const ::flatbuffers::String *observation_period() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBSERVATION_PERIOD);
  }
  const BlpConn::FB::DateTime *release_start_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_RELEASE_START_DT);
  }
  const BlpConn::FB::DateTime *release_end_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_RELEASE_END_DT);
  }
  int32_t prior_event_id() const {
    return GetField<int32_t>(VT_PRIOR_EVENT_ID, 0);
  }
  const ::flatbuffers::String *prior_observation_period() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRIOR_OBSERVATION_PERIOD);
  }
  const BlpConn::FB::DateTime *prior_economic_release_start_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_PRIOR_ECONOMIC_RELEASE_START_DT);
  }
  const BlpConn::FB::DateTime *prior_economic_release_end_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_PRIOR_ECONOMIC_RELEASE_END_DT);
  }
  const BlpConn::FB::Value *value() const {
    return GetPointer<const BlpConn::FB::Value *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CORR_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_SUBTYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_EVENT_ID, 4) &&
           VerifyOffset(verifier, VT_OBSERVATION_PERIOD) &&
           verifier.VerifyString(observation_period()) &&
           VerifyOffset(verifier, VT_RELEASE_START_DT) &&
           verifier.VerifyTable(release_start_dt()) &&
           VerifyOffset(verifier, VT_RELEASE_END_DT) &&
           verifier.VerifyTable(release_end_dt()) &&
           VerifyField<int32_t>(verifier, VT_PRIOR_EVENT_ID, 4) &&
           VerifyOffset(verifier, VT_PRIOR_OBSERVATION_PERIOD) &&
           verifier.VerifyString(prior_observation_period()) &&
           VerifyOffset(verifier, VT_PRIOR_ECONOMIC_RELEASE_START_DT) &&
           verifier.VerifyTable(prior_economic_release_start_dt()) &&
           VerifyOffset(verifier, VT_PRIOR_ECONOMIC_RELEASE_END_DT) &&
           verifier.VerifyTable(prior_economic_release_end_dt()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct MacroHeadlineEventBuilder {
  typedef MacroHeadlineEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_corr_id(int64_t corr_id) {
    fbb_.AddElement<int64_t>(MacroHeadlineEvent::VT_CORR_ID, corr_id, 0);
  }
  void add_event_type(BlpConn::FB::EventType event_type) {
    fbb_.AddElement<uint8_t>(MacroHeadlineEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event_subtype(BlpConn::FB::EventSubType event_subtype) {
    fbb_.AddElement<uint8_t>(MacroHeadlineEvent::VT_EVENT_SUBTYPE, static_cast<uint8_t>(event_subtype), 0);
  }
  void add_event_id(int32_t event_id) {
    fbb_.AddElement<int32_t>(MacroHeadlineEvent::VT_EVENT_ID, event_id, 0);
  }
  void add_observation_period(::flatbuffers::Offset<::flatbuffers::String> observation_period) {
    fbb_.AddOffset(MacroHeadlineEvent::VT_OBSERVATION_PERIOD, observation_period);
  }
  void add_release_start_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt) {
    fbb_.AddOffset(MacroHeadlineEvent::VT_RELEASE_START_DT, release_start_dt);
  }
  void add_release_end_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt) {
    fbb_.AddOffset(MacroHeadlineEvent::VT_RELEASE_END_DT, release_end_dt);
  }
  void add_prior_event_id(int32_t prior_event_id) {
    fbb_.AddElement<int32_t>(MacroHeadlineEvent::VT_PRIOR_EVENT_ID, prior_event_id, 0);
  }
  void add_prior_observation_period(::flatbuffers::Offset<::flatbuffers::String> prior_observation_period) {
    fbb_.AddOffset(MacroHeadlineEvent::VT_PRIOR_OBSERVATION_PERIOD, prior_observation_period);
  }
  void add_prior_economic_release_start_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_start_dt) {
    fbb_.AddOffset(MacroHeadlineEvent::VT_PRIOR_ECONOMIC_RELEASE_START_DT, prior_economic_release_start_dt);
  }
  void add_prior_economic_release_end_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_end_dt) {
    fbb_.AddOffset(MacroHeadlineEvent::VT_PRIOR_ECONOMIC_RELEASE_END_DT, prior_economic_release_end_dt);
  }
  void add_value(::flatbuffers::Offset<BlpConn::FB::Value> value) {
    fbb_.AddOffset(MacroHeadlineEvent::VT_VALUE, value);
  }
  explicit MacroHeadlineEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MacroHeadlineEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MacroHeadlineEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MacroHeadlineEvent> CreateMacroHeadlineEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t corr_id = 0,
    BlpConn::FB::EventType event_type = BlpConn::FB::EventType_Unknown,
    BlpConn::FB::EventSubType event_subtype = BlpConn::FB::EventSubType_Unknown,
    int32_t event_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> observation_period = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt = 0,
    int32_t prior_event_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> prior_observation_period = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_end_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::Value> value = 0) {
  MacroHeadlineEventBuilder builder_(_fbb);
  builder_.add_corr_id(corr_id);
  builder_.add_value(value);
  builder_.add_prior_economic_release_end_dt(prior_economic_release_end_dt);
  builder_.add_prior_economic_release_start_dt(prior_economic_release_start_dt);
  builder_.add_prior_observation_period(prior_observation_period);
  builder_.add_prior_event_id(prior_event_id);
  builder_.add_release_end_dt(release_end_dt);
  builder_.add_release_start_dt(release_start_dt);
  builder_.add_observation_period(observation_period);
  builder_.add_event_id(event_id);
  builder_.add_event_subtype(event_subtype);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MacroHeadlineEvent> CreateMacroHeadlineEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t corr_id = 0,
    BlpConn::FB::EventType event_type = BlpConn::FB::EventType_Unknown,
    BlpConn::FB::EventSubType event_subtype = BlpConn::FB::EventSubType_Unknown,
    int32_t event_id = 0,
    const char *observation_period = nullptr,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt = 0,
    int32_t prior_event_id = 0,
    const char *prior_observation_period = nullptr,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_end_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::Value> value = 0) {
  auto observation_period__ = observation_period ? _fbb.CreateString(observation_period) : 0;
  auto prior_observation_period__ = prior_observation_period ? _fbb.CreateString(prior_observation_period) : 0;
  return BlpConn::FB::CreateMacroHeadlineEvent(
      _fbb,
      corr_id,
      event_type,
      event_subtype,
      event_id,
      observation_period__,
      release_start_dt,
      release_end_dt,
      prior_event_id,
      prior_observation_period__,
      prior_economic_release_start_dt,
      prior_economic_release_end_dt,
      value);
}

struct MacroCalendarEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MacroCalendarEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CORR_ID = 4,
    VT_ID_BB_GLOBAL = 6,
    VT_PARSEKYABLE_DES = 8,
    VT_EVENT_TYPE = 10,
    VT_EVENT_SUBTYPE = 12,
    VT_DESCRIPTION = 14,
    VT_EVENT_ID = 16,
    VT_OBSERVATION_PERIOD = 18,
    VT_RELEASE_START_DT = 20,
    VT_RELEASE_END_DT = 22,
    VT_RELEASE_STATUS = 24,
    VT_RELEVANCE_VALUE = 26
  };
  int64_t corr_id() const {
    return GetField<int64_t>(VT_CORR_ID, 0);
  }
  const ::flatbuffers::String *id_bb_global() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_BB_GLOBAL);
  }
  const ::flatbuffers::String *parsekyable_des() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARSEKYABLE_DES);
  }
  BlpConn::FB::EventType event_type() const {
    return static_cast<BlpConn::FB::EventType>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  BlpConn::FB::EventSubType event_subtype() const {
    return static_cast<BlpConn::FB::EventSubType>(GetField<uint8_t>(VT_EVENT_SUBTYPE, 0));
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  int32_t event_id() const {
    return GetField<int32_t>(VT_EVENT_ID, 0);
  }
  const ::flatbuffers::String *observation_period() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBSERVATION_PERIOD);
  }
  const BlpConn::FB::DateTime *release_start_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_RELEASE_START_DT);
  }
  const BlpConn::FB::DateTime *release_end_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_RELEASE_END_DT);
  }
  BlpConn::FB::ReleaseStatus release_status() const {
    return static_cast<BlpConn::FB::ReleaseStatus>(GetField<uint8_t>(VT_RELEASE_STATUS, 0));
  }
  double relevance_value() const {
    return GetField<double>(VT_RELEVANCE_VALUE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CORR_ID, 8) &&
           VerifyOffsetRequired(verifier, VT_ID_BB_GLOBAL) &&
           verifier.VerifyString(id_bb_global()) &&
           VerifyOffsetRequired(verifier, VT_PARSEKYABLE_DES) &&
           verifier.VerifyString(parsekyable_des()) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_SUBTYPE, 1) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<int32_t>(verifier, VT_EVENT_ID, 4) &&
           VerifyOffset(verifier, VT_OBSERVATION_PERIOD) &&
           verifier.VerifyString(observation_period()) &&
           VerifyOffset(verifier, VT_RELEASE_START_DT) &&
           verifier.VerifyTable(release_start_dt()) &&
           VerifyOffset(verifier, VT_RELEASE_END_DT) &&
           verifier.VerifyTable(release_end_dt()) &&
           VerifyField<uint8_t>(verifier, VT_RELEASE_STATUS, 1) &&
           VerifyField<double>(verifier, VT_RELEVANCE_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct MacroCalendarEventBuilder {
  typedef MacroCalendarEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_corr_id(int64_t corr_id) {
    fbb_.AddElement<int64_t>(MacroCalendarEvent::VT_CORR_ID, corr_id, 0);
  }
  void add_id_bb_global(::flatbuffers::Offset<::flatbuffers::String> id_bb_global) {
    fbb_.AddOffset(MacroCalendarEvent::VT_ID_BB_GLOBAL, id_bb_global);
  }
  void add_parsekyable_des(::flatbuffers::Offset<::flatbuffers::String> parsekyable_des) {
    fbb_.AddOffset(MacroCalendarEvent::VT_PARSEKYABLE_DES, parsekyable_des);
  }
  void add_event_type(BlpConn::FB::EventType event_type) {
    fbb_.AddElement<uint8_t>(MacroCalendarEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event_subtype(BlpConn::FB::EventSubType event_subtype) {
    fbb_.AddElement<uint8_t>(MacroCalendarEvent::VT_EVENT_SUBTYPE, static_cast<uint8_t>(event_subtype), 0);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(MacroCalendarEvent::VT_DESCRIPTION, description);
  }
  void add_event_id(int32_t event_id) {
    fbb_.AddElement<int32_t>(MacroCalendarEvent::VT_EVENT_ID, event_id, 0);
  }
  void add_observation_period(::flatbuffers::Offset<::flatbuffers::String> observation_period) {
    fbb_.AddOffset(MacroCalendarEvent::VT_OBSERVATION_PERIOD, observation_period);
  }
  void add_release_start_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt) {
    fbb_.AddOffset(MacroCalendarEvent::VT_RELEASE_START_DT, release_start_dt);
  }
  void add_release_end_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt) {
    fbb_.AddOffset(MacroCalendarEvent::VT_RELEASE_END_DT, release_end_dt);
  }
  void add_release_status(BlpConn::FB::ReleaseStatus release_status) {
    fbb_.AddElement<uint8_t>(MacroCalendarEvent::VT_RELEASE_STATUS, static_cast<uint8_t>(release_status), 0);
  }
  void add_relevance_value(double relevance_value) {
    fbb_.AddElement<double>(MacroCalendarEvent::VT_RELEVANCE_VALUE, relevance_value, 0.0);
  }
  explicit MacroCalendarEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MacroCalendarEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MacroCalendarEvent>(end);
    fbb_.Required(o, MacroCalendarEvent::VT_ID_BB_GLOBAL);
    fbb_.Required(o, MacroCalendarEvent::VT_PARSEKYABLE_DES);
    return o;
  }
};

inline ::flatbuffers::Offset<MacroCalendarEvent> CreateMacroCalendarEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t corr_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> id_bb_global = 0,
    ::flatbuffers::Offset<::flatbuffers::String> parsekyable_des = 0,
    BlpConn::FB::EventType event_type = BlpConn::FB::EventType_Unknown,
    BlpConn::FB::EventSubType event_subtype = BlpConn::FB::EventSubType_Unknown,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    int32_t event_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> observation_period = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt = 0,
    BlpConn::FB::ReleaseStatus release_status = BlpConn::FB::ReleaseStatus_Unknown,
    double relevance_value = 0.0) {
  MacroCalendarEventBuilder builder_(_fbb);
  builder_.add_relevance_value(relevance_value);
  builder_.add_corr_id(corr_id);
  builder_.add_release_end_dt(release_end_dt);
  builder_.add_release_start_dt(release_start_dt);
  builder_.add_observation_period(observation_period);
  builder_.add_event_id(event_id);
  builder_.add_description(description);
  builder_.add_parsekyable_des(parsekyable_des);
  builder_.add_id_bb_global(id_bb_global);
  builder_.add_release_status(release_status);
  builder_.add_event_subtype(event_subtype);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MacroCalendarEvent> CreateMacroCalendarEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t corr_id = 0,
    const char *id_bb_global = nullptr,
    const char *parsekyable_des = nullptr,
    BlpConn::FB::EventType event_type = BlpConn::FB::EventType_Unknown,
    BlpConn::FB::EventSubType event_subtype = BlpConn::FB::EventSubType_Unknown,
    const char *description = nullptr,
    int32_t event_id = 0,
    const char *observation_period = nullptr,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt = 0,
    BlpConn::FB::ReleaseStatus release_status = BlpConn::FB::ReleaseStatus_Unknown,
    double relevance_value = 0.0) {
  auto id_bb_global__ = id_bb_global ? _fbb.CreateString(id_bb_global) : 0;
  auto parsekyable_des__ = parsekyable_des ? _fbb.CreateString(parsekyable_des) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto observation_period__ = observation_period ? _fbb.CreateString(observation_period) : 0;
  return BlpConn::FB::CreateMacroCalendarEvent(
      _fbb,
      corr_id,
      id_bb_global__,
      parsekyable_des__,
      event_type,
      event_subtype,
      description__,
      event_id,
      observation_period__,
      release_start_dt,
      release_end_dt,
      release_status,
      relevance_value);
}

struct HeadlineCalendarEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeadlineCalendarEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_BB_GLOBAL = 4,
    VT_PARSEKYABLE_DES = 6,
    VT_DESCRIPTION = 8,
    VT_EVENT_TYPE = 10,
    VT_EVENT_SUBTYPE = 12,
    VT_EVENT_ID = 14,
    VT_OBSERVATION_PERIOD = 16,
    VT_RELEASE_START_DT = 18,
    VT_RELEASE_END_DT = 20,
    VT_RELEASE_STATUS = 22
  };
  const ::flatbuffers::String *id_bb_global() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_BB_GLOBAL);
  }
  const ::flatbuffers::String *parsekyable_des() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARSEKYABLE_DES);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  BlpConn::FB::EventType event_type() const {
    return static_cast<BlpConn::FB::EventType>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  BlpConn::FB::EventSubType event_subtype() const {
    return static_cast<BlpConn::FB::EventSubType>(GetField<uint8_t>(VT_EVENT_SUBTYPE, 0));
  }
  int32_t event_id() const {
    return GetField<int32_t>(VT_EVENT_ID, 0);
  }
  const ::flatbuffers::String *observation_period() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBSERVATION_PERIOD);
  }
  const BlpConn::FB::DateTime *release_start_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_RELEASE_START_DT);
  }
  const BlpConn::FB::DateTime *release_end_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_RELEASE_END_DT);
  }
  BlpConn::FB::ReleaseStatus release_status() const {
    return static_cast<BlpConn::FB::ReleaseStatus>(GetField<uint8_t>(VT_RELEASE_STATUS, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID_BB_GLOBAL) &&
           verifier.VerifyString(id_bb_global()) &&
           VerifyOffsetRequired(verifier, VT_PARSEKYABLE_DES) &&
           verifier.VerifyString(parsekyable_des()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_SUBTYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_EVENT_ID, 4) &&
           VerifyOffset(verifier, VT_OBSERVATION_PERIOD) &&
           verifier.VerifyString(observation_period()) &&
           VerifyOffset(verifier, VT_RELEASE_START_DT) &&
           verifier.VerifyTable(release_start_dt()) &&
           VerifyOffset(verifier, VT_RELEASE_END_DT) &&
           verifier.VerifyTable(release_end_dt()) &&
           VerifyField<uint8_t>(verifier, VT_RELEASE_STATUS, 1) &&
           verifier.EndTable();
  }
};

struct HeadlineCalendarEventBuilder {
  typedef HeadlineCalendarEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id_bb_global(::flatbuffers::Offset<::flatbuffers::String> id_bb_global) {
    fbb_.AddOffset(HeadlineCalendarEvent::VT_ID_BB_GLOBAL, id_bb_global);
  }
  void add_parsekyable_des(::flatbuffers::Offset<::flatbuffers::String> parsekyable_des) {
    fbb_.AddOffset(HeadlineCalendarEvent::VT_PARSEKYABLE_DES, parsekyable_des);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(HeadlineCalendarEvent::VT_DESCRIPTION, description);
  }
  void add_event_type(BlpConn::FB::EventType event_type) {
    fbb_.AddElement<uint8_t>(HeadlineCalendarEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event_subtype(BlpConn::FB::EventSubType event_subtype) {
    fbb_.AddElement<uint8_t>(HeadlineCalendarEvent::VT_EVENT_SUBTYPE, static_cast<uint8_t>(event_subtype), 0);
  }
  void add_event_id(int32_t event_id) {
    fbb_.AddElement<int32_t>(HeadlineCalendarEvent::VT_EVENT_ID, event_id, 0);
  }
  void add_observation_period(::flatbuffers::Offset<::flatbuffers::String> observation_period) {
    fbb_.AddOffset(HeadlineCalendarEvent::VT_OBSERVATION_PERIOD, observation_period);
  }
  void add_release_start_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt) {
    fbb_.AddOffset(HeadlineCalendarEvent::VT_RELEASE_START_DT, release_start_dt);
  }
  void add_release_end_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt) {
    fbb_.AddOffset(HeadlineCalendarEvent::VT_RELEASE_END_DT, release_end_dt);
  }
  void add_release_status(BlpConn::FB::ReleaseStatus release_status) {
    fbb_.AddElement<uint8_t>(HeadlineCalendarEvent::VT_RELEASE_STATUS, static_cast<uint8_t>(release_status), 0);
  }
  explicit HeadlineCalendarEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HeadlineCalendarEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HeadlineCalendarEvent>(end);
    fbb_.Required(o, HeadlineCalendarEvent::VT_ID_BB_GLOBAL);
    fbb_.Required(o, HeadlineCalendarEvent::VT_PARSEKYABLE_DES);
    return o;
  }
};

inline ::flatbuffers::Offset<HeadlineCalendarEvent> CreateHeadlineCalendarEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id_bb_global = 0,
    ::flatbuffers::Offset<::flatbuffers::String> parsekyable_des = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    BlpConn::FB::EventType event_type = BlpConn::FB::EventType_Unknown,
    BlpConn::FB::EventSubType event_subtype = BlpConn::FB::EventSubType_Unknown,
    int32_t event_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> observation_period = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt = 0,
    BlpConn::FB::ReleaseStatus release_status = BlpConn::FB::ReleaseStatus_Unknown) {
  HeadlineCalendarEventBuilder builder_(_fbb);
  builder_.add_release_end_dt(release_end_dt);
  builder_.add_release_start_dt(release_start_dt);
  builder_.add_observation_period(observation_period);
  builder_.add_event_id(event_id);
  builder_.add_description(description);
  builder_.add_parsekyable_des(parsekyable_des);
  builder_.add_id_bb_global(id_bb_global);
  builder_.add_release_status(release_status);
  builder_.add_event_subtype(event_subtype);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HeadlineCalendarEvent> CreateHeadlineCalendarEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id_bb_global = nullptr,
    const char *parsekyable_des = nullptr,
    const char *description = nullptr,
    BlpConn::FB::EventType event_type = BlpConn::FB::EventType_Unknown,
    BlpConn::FB::EventSubType event_subtype = BlpConn::FB::EventSubType_Unknown,
    int32_t event_id = 0,
    const char *observation_period = nullptr,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt = 0,
    BlpConn::FB::ReleaseStatus release_status = BlpConn::FB::ReleaseStatus_Unknown) {
  auto id_bb_global__ = id_bb_global ? _fbb.CreateString(id_bb_global) : 0;
  auto parsekyable_des__ = parsekyable_des ? _fbb.CreateString(parsekyable_des) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto observation_period__ = observation_period ? _fbb.CreateString(observation_period) : 0;
  return BlpConn::FB::CreateHeadlineCalendarEvent(
      _fbb,
      id_bb_global__,
      parsekyable_des__,
      description__,
      event_type,
      event_subtype,
      event_id,
      observation_period__,
      release_start_dt,
      release_end_dt,
      release_status);
}

struct LogMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOG_DT = 4,
    VT_MODULE_ = 6,
    VT_STATUS = 8,
    VT_CORR_ID = 10,
    VT_MESSAGE = 12
  };
  const BlpConn::FB::DateTime *log_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_LOG_DT);
  }
  uint8_t module_() const {
    return GetField<uint8_t>(VT_MODULE_, 0);
  }
  uint8_t status() const {
    return GetField<uint8_t>(VT_STATUS, 0);
  }
  uint64_t corr_id() const {
    return GetField<uint64_t>(VT_CORR_ID, 0);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOG_DT) &&
           verifier.VerifyTable(log_dt()) &&
           VerifyField<uint8_t>(verifier, VT_MODULE_, 1) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<uint64_t>(verifier, VT_CORR_ID, 8) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct LogMessageBuilder {
  typedef LogMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_log_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> log_dt) {
    fbb_.AddOffset(LogMessage::VT_LOG_DT, log_dt);
  }
  void add_module_(uint8_t module_) {
    fbb_.AddElement<uint8_t>(LogMessage::VT_MODULE_, module_, 0);
  }
  void add_status(uint8_t status) {
    fbb_.AddElement<uint8_t>(LogMessage::VT_STATUS, status, 0);
  }
  void add_corr_id(uint64_t corr_id) {
    fbb_.AddElement<uint64_t>(LogMessage::VT_CORR_ID, corr_id, 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(LogMessage::VT_MESSAGE, message);
  }
  explicit LogMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogMessage> CreateLogMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> log_dt = 0,
    uint8_t module_ = 0,
    uint8_t status = 0,
    uint64_t corr_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  LogMessageBuilder builder_(_fbb);
  builder_.add_corr_id(corr_id);
  builder_.add_message(message);
  builder_.add_log_dt(log_dt);
  builder_.add_status(status);
  builder_.add_module_(module_);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LogMessage> CreateLogMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> log_dt = 0,
    uint8_t module_ = 0,
    uint8_t status = 0,
    uint64_t corr_id = 0,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return BlpConn::FB::CreateLogMessage(
      _fbb,
      log_dt,
      module_,
      status,
      corr_id,
      message__);
}

struct Main FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MainBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  BlpConn::FB::Message message_type() const {
    return static_cast<BlpConn::FB::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const BlpConn::FB::HeadlineEconomicEvent *message_as_HeadlineEconomicEvent() const {
    return message_type() == BlpConn::FB::Message_HeadlineEconomicEvent ? static_cast<const BlpConn::FB::HeadlineEconomicEvent *>(message()) : nullptr;
  }
  const BlpConn::FB::HeadlineCalendarEvent *message_as_HeadlineCalendarEvent() const {
    return message_type() == BlpConn::FB::Message_HeadlineCalendarEvent ? static_cast<const BlpConn::FB::HeadlineCalendarEvent *>(message()) : nullptr;
  }
  const BlpConn::FB::MacroReferenceData *message_as_MacroReferenceData() const {
    return message_type() == BlpConn::FB::Message_MacroReferenceData ? static_cast<const BlpConn::FB::MacroReferenceData *>(message()) : nullptr;
  }
  const BlpConn::FB::MacroHeadlineEvent *message_as_MacroHeadlineEvent() const {
    return message_type() == BlpConn::FB::Message_MacroHeadlineEvent ? static_cast<const BlpConn::FB::MacroHeadlineEvent *>(message()) : nullptr;
  }
  const BlpConn::FB::MacroCalendarEvent *message_as_MacroCalendarEvent() const {
    return message_type() == BlpConn::FB::Message_MacroCalendarEvent ? static_cast<const BlpConn::FB::MacroCalendarEvent *>(message()) : nullptr;
  }
  const BlpConn::FB::LogMessage *message_as_LogMessage() const {
    return message_type() == BlpConn::FB::Message_LogMessage ? static_cast<const BlpConn::FB::LogMessage *>(message()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const BlpConn::FB::HeadlineEconomicEvent *Main::message_as<BlpConn::FB::HeadlineEconomicEvent>() const {
  return message_as_HeadlineEconomicEvent();
}

template<> inline const BlpConn::FB::HeadlineCalendarEvent *Main::message_as<BlpConn::FB::HeadlineCalendarEvent>() const {
  return message_as_HeadlineCalendarEvent();
}

template<> inline const BlpConn::FB::MacroReferenceData *Main::message_as<BlpConn::FB::MacroReferenceData>() const {
  return message_as_MacroReferenceData();
}

template<> inline const BlpConn::FB::MacroHeadlineEvent *Main::message_as<BlpConn::FB::MacroHeadlineEvent>() const {
  return message_as_MacroHeadlineEvent();
}

template<> inline const BlpConn::FB::MacroCalendarEvent *Main::message_as<BlpConn::FB::MacroCalendarEvent>() const {
  return message_as_MacroCalendarEvent();
}

template<> inline const BlpConn::FB::LogMessage *Main::message_as<BlpConn::FB::LogMessage>() const {
  return message_as_LogMessage();
}

struct MainBuilder {
  typedef Main Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_type(BlpConn::FB::Message message_type) {
    fbb_.AddElement<uint8_t>(Main::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(::flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Main::VT_MESSAGE, message);
  }
  explicit MainBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Main> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Main>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Main> CreateMain(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    BlpConn::FB::Message message_type = BlpConn::FB::Message_NONE,
    ::flatbuffers::Offset<void> message = 0) {
  MainBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_HeadlineEconomicEvent: {
      auto ptr = reinterpret_cast<const BlpConn::FB::HeadlineEconomicEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_HeadlineCalendarEvent: {
      auto ptr = reinterpret_cast<const BlpConn::FB::HeadlineCalendarEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_MacroReferenceData: {
      auto ptr = reinterpret_cast<const BlpConn::FB::MacroReferenceData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_MacroHeadlineEvent: {
      auto ptr = reinterpret_cast<const BlpConn::FB::MacroHeadlineEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_MacroCalendarEvent: {
      auto ptr = reinterpret_cast<const BlpConn::FB::MacroCalendarEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_LogMessage: {
      auto ptr = reinterpret_cast<const BlpConn::FB::LogMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace FB
}  // namespace BlpConn

#endif  // FLATBUFFERS_GENERATED_BLPCONNFB_BLPCONN_FB_H_
