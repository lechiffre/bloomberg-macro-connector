// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BLPCONNFB_BLPCONN_FB_H_
#define FLATBUFFERS_GENERATED_BLPCONNFB_BLPCONN_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace BlpConn {
namespace FB {

struct DateTime;
struct DateTimeBuilder;

struct Value;
struct ValueBuilder;

struct HeadlineEconomicEvent;
struct HeadlineEconomicEventBuilder;

struct HeadlineCalendarEvent;
struct HeadlineCalendarEventBuilder;

struct LogMessage;
struct LogMessageBuilder;

struct Main;
struct MainBuilder;

enum ReleaseStatus : int32_t {
  ReleaseStatus_Unknown = 0,
  ReleaseStatus_Released = 1,
  ReleaseStatus_Scheduled = 2,
  ReleaseStatus_Another = 99,
  ReleaseStatus_MIN = ReleaseStatus_Unknown,
  ReleaseStatus_MAX = ReleaseStatus_Another
};

inline const ReleaseStatus (&EnumValuesReleaseStatus())[4] {
  static const ReleaseStatus values[] = {
    ReleaseStatus_Unknown,
    ReleaseStatus_Released,
    ReleaseStatus_Scheduled,
    ReleaseStatus_Another
  };
  return values;
}

inline const char *EnumNameReleaseStatus(ReleaseStatus e) {
  switch (e) {
    case ReleaseStatus_Unknown: return "Unknown";
    case ReleaseStatus_Released: return "Released";
    case ReleaseStatus_Scheduled: return "Scheduled";
    case ReleaseStatus_Another: return "Another";
    default: return "";
  }
}

enum EventSubType : int32_t {
  EventSubType_Unknown = 0,
  EventSubType_New = 1,
  EventSubType_Update = 2,
  EventSubType_Unitpaint = 3,
  EventSubType_Delete = 4,
  EventSubType_Another = 99,
  EventSubType_MIN = EventSubType_Unknown,
  EventSubType_MAX = EventSubType_Another
};

inline const EventSubType (&EnumValuesEventSubType())[6] {
  static const EventSubType values[] = {
    EventSubType_Unknown,
    EventSubType_New,
    EventSubType_Update,
    EventSubType_Unitpaint,
    EventSubType_Delete,
    EventSubType_Another
  };
  return values;
}

inline const char *EnumNameEventSubType(EventSubType e) {
  switch (e) {
    case EventSubType_Unknown: return "Unknown";
    case EventSubType_New: return "New";
    case EventSubType_Update: return "Update";
    case EventSubType_Unitpaint: return "Unitpaint";
    case EventSubType_Delete: return "Delete";
    case EventSubType_Another: return "Another";
    default: return "";
  }
}

enum EventType : int32_t {
  EventType_Unknown = 0,
  EventType_Actual = 1,
  EventType_Revision = 2,
  EventType_Estimate = 3,
  EventType_Calendar = 4,
  EventType_Another = 99,
  EventType_MIN = EventType_Unknown,
  EventType_MAX = EventType_Another
};

inline const EventType (&EnumValuesEventType())[6] {
  static const EventType values[] = {
    EventType_Unknown,
    EventType_Actual,
    EventType_Revision,
    EventType_Estimate,
    EventType_Calendar,
    EventType_Another
  };
  return values;
}

inline const char *EnumNameEventType(EventType e) {
  switch (e) {
    case EventType_Unknown: return "Unknown";
    case EventType_Actual: return "Actual";
    case EventType_Revision: return "Revision";
    case EventType_Estimate: return "Estimate";
    case EventType_Calendar: return "Calendar";
    case EventType_Another: return "Another";
    default: return "";
  }
}

enum Message : uint8_t {
  Message_NONE = 0,
  Message_HeadlineEconomicEvent = 1,
  Message_HeadlineCalendarEvent = 2,
  Message_LogMessage = 3,
  Message_MIN = Message_NONE,
  Message_MAX = Message_LogMessage
};

inline const Message (&EnumValuesMessage())[4] {
  static const Message values[] = {
    Message_NONE,
    Message_HeadlineEconomicEvent,
    Message_HeadlineCalendarEvent,
    Message_LogMessage
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[5] = {
    "NONE",
    "HeadlineEconomicEvent",
    "HeadlineCalendarEvent",
    "LogMessage",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (::flatbuffers::IsOutRange(e, Message_NONE, Message_LogMessage)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<BlpConn::FB::HeadlineEconomicEvent> {
  static const Message enum_value = Message_HeadlineEconomicEvent;
};

template<> struct MessageTraits<BlpConn::FB::HeadlineCalendarEvent> {
  static const Message enum_value = Message_HeadlineCalendarEvent;
};

template<> struct MessageTraits<BlpConn::FB::LogMessage> {
  static const Message enum_value = Message_LogMessage;
};

bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct DateTime FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DateTimeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MICROS = 4,
    VT_OFFSET = 6
  };
  uint64_t micros() const {
    return GetField<uint64_t>(VT_MICROS, 0);
  }
  int16_t offset() const {
    return GetField<int16_t>(VT_OFFSET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MICROS, 8) &&
           VerifyField<int16_t>(verifier, VT_OFFSET, 2) &&
           verifier.EndTable();
  }
};

struct DateTimeBuilder {
  typedef DateTime Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_micros(uint64_t micros) {
    fbb_.AddElement<uint64_t>(DateTime::VT_MICROS, micros, 0);
  }
  void add_offset(int16_t offset) {
    fbb_.AddElement<int16_t>(DateTime::VT_OFFSET, offset, 0);
  }
  explicit DateTimeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DateTime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DateTime>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DateTime> CreateDateTime(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t micros = 0,
    int16_t offset = 0) {
  DateTimeBuilder builder_(_fbb);
  builder_.add_micros(micros);
  builder_.add_offset(offset);
  return builder_.Finish();
}

struct Value FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBER = 4,
    VT_VALUE = 6,
    VT_LOW = 8,
    VT_HIGH = 10,
    VT_MEDIAN = 12,
    VT_AVERAGE = 14,
    VT_STANDARD_DEVIATION = 16
  };
  double number() const {
    return GetField<double>(VT_NUMBER, 0.0);
  }
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  double low() const {
    return GetField<double>(VT_LOW, 0.0);
  }
  double high() const {
    return GetField<double>(VT_HIGH, 0.0);
  }
  double median() const {
    return GetField<double>(VT_MEDIAN, 0.0);
  }
  double average() const {
    return GetField<double>(VT_AVERAGE, 0.0);
  }
  double standard_deviation() const {
    return GetField<double>(VT_STANDARD_DEVIATION, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_NUMBER, 8) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           VerifyField<double>(verifier, VT_LOW, 8) &&
           VerifyField<double>(verifier, VT_HIGH, 8) &&
           VerifyField<double>(verifier, VT_MEDIAN, 8) &&
           VerifyField<double>(verifier, VT_AVERAGE, 8) &&
           VerifyField<double>(verifier, VT_STANDARD_DEVIATION, 8) &&
           verifier.EndTable();
  }
};

struct ValueBuilder {
  typedef Value Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_number(double number) {
    fbb_.AddElement<double>(Value::VT_NUMBER, number, 0.0);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(Value::VT_VALUE, value, 0.0);
  }
  void add_low(double low) {
    fbb_.AddElement<double>(Value::VT_LOW, low, 0.0);
  }
  void add_high(double high) {
    fbb_.AddElement<double>(Value::VT_HIGH, high, 0.0);
  }
  void add_median(double median) {
    fbb_.AddElement<double>(Value::VT_MEDIAN, median, 0.0);
  }
  void add_average(double average) {
    fbb_.AddElement<double>(Value::VT_AVERAGE, average, 0.0);
  }
  void add_standard_deviation(double standard_deviation) {
    fbb_.AddElement<double>(Value::VT_STANDARD_DEVIATION, standard_deviation, 0.0);
  }
  explicit ValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Value>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Value> CreateValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double number = 0.0,
    double value = 0.0,
    double low = 0.0,
    double high = 0.0,
    double median = 0.0,
    double average = 0.0,
    double standard_deviation = 0.0) {
  ValueBuilder builder_(_fbb);
  builder_.add_standard_deviation(standard_deviation);
  builder_.add_average(average);
  builder_.add_median(median);
  builder_.add_high(high);
  builder_.add_low(low);
  builder_.add_value(value);
  builder_.add_number(number);
  return builder_.Finish();
}

struct HeadlineEconomicEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeadlineEconomicEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_BB_GLOBAL = 4,
    VT_PARSEKYABLE_DES = 6,
    VT_DESCRIPTION = 8,
    VT_EVENT_TYPE = 10,
    VT_EVENT_SUBTYPE = 12,
    VT_EVENT_ID = 14,
    VT_OBSERVATION_PERIOD = 16,
    VT_RELEASE_START_DT = 18,
    VT_RELEASE_END_DT = 20,
    VT_VALUE = 22,
    VT_PRIOR_VALUE = 24,
    VT_PRIOR_EVENT_ID = 26,
    VT_PRIOR_OBSERVATION_PERIOD = 28,
    VT_PRIOR_ECONOMIC_RELEASE_START_DT = 30,
    VT_PRIOR_ECONOMIC_RELEASE_END_DT = 32
  };
  const ::flatbuffers::String *id_bb_global() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_BB_GLOBAL);
  }
  const ::flatbuffers::String *parsekyable_des() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARSEKYABLE_DES);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  BlpConn::FB::EventType event_type() const {
    return static_cast<BlpConn::FB::EventType>(GetField<int32_t>(VT_EVENT_TYPE, 0));
  }
  BlpConn::FB::EventSubType event_subtype() const {
    return static_cast<BlpConn::FB::EventSubType>(GetField<int32_t>(VT_EVENT_SUBTYPE, 0));
  }
  int32_t event_id() const {
    return GetField<int32_t>(VT_EVENT_ID, 0);
  }
  const ::flatbuffers::String *observation_period() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBSERVATION_PERIOD);
  }
  const BlpConn::FB::DateTime *release_start_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_RELEASE_START_DT);
  }
  const BlpConn::FB::DateTime *release_end_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_RELEASE_END_DT);
  }
  const BlpConn::FB::Value *value() const {
    return GetPointer<const BlpConn::FB::Value *>(VT_VALUE);
  }
  const BlpConn::FB::Value *prior_value() const {
    return GetPointer<const BlpConn::FB::Value *>(VT_PRIOR_VALUE);
  }
  int32_t prior_event_id() const {
    return GetField<int32_t>(VT_PRIOR_EVENT_ID, 0);
  }
  const ::flatbuffers::String *prior_observation_period() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRIOR_OBSERVATION_PERIOD);
  }
  const BlpConn::FB::DateTime *prior_economic_release_start_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_PRIOR_ECONOMIC_RELEASE_START_DT);
  }
  const BlpConn::FB::DateTime *prior_economic_release_end_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_PRIOR_ECONOMIC_RELEASE_END_DT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID_BB_GLOBAL) &&
           verifier.VerifyString(id_bb_global()) &&
           VerifyOffsetRequired(verifier, VT_PARSEKYABLE_DES) &&
           verifier.VerifyString(parsekyable_des()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<int32_t>(verifier, VT_EVENT_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_EVENT_SUBTYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_EVENT_ID, 4) &&
           VerifyOffset(verifier, VT_OBSERVATION_PERIOD) &&
           verifier.VerifyString(observation_period()) &&
           VerifyOffset(verifier, VT_RELEASE_START_DT) &&
           verifier.VerifyTable(release_start_dt()) &&
           VerifyOffset(verifier, VT_RELEASE_END_DT) &&
           verifier.VerifyTable(release_end_dt()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyOffset(verifier, VT_PRIOR_VALUE) &&
           verifier.VerifyTable(prior_value()) &&
           VerifyField<int32_t>(verifier, VT_PRIOR_EVENT_ID, 4) &&
           VerifyOffset(verifier, VT_PRIOR_OBSERVATION_PERIOD) &&
           verifier.VerifyString(prior_observation_period()) &&
           VerifyOffset(verifier, VT_PRIOR_ECONOMIC_RELEASE_START_DT) &&
           verifier.VerifyTable(prior_economic_release_start_dt()) &&
           VerifyOffset(verifier, VT_PRIOR_ECONOMIC_RELEASE_END_DT) &&
           verifier.VerifyTable(prior_economic_release_end_dt()) &&
           verifier.EndTable();
  }
};

struct HeadlineEconomicEventBuilder {
  typedef HeadlineEconomicEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id_bb_global(::flatbuffers::Offset<::flatbuffers::String> id_bb_global) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_ID_BB_GLOBAL, id_bb_global);
  }
  void add_parsekyable_des(::flatbuffers::Offset<::flatbuffers::String> parsekyable_des) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_PARSEKYABLE_DES, parsekyable_des);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_DESCRIPTION, description);
  }
  void add_event_type(BlpConn::FB::EventType event_type) {
    fbb_.AddElement<int32_t>(HeadlineEconomicEvent::VT_EVENT_TYPE, static_cast<int32_t>(event_type), 0);
  }
  void add_event_subtype(BlpConn::FB::EventSubType event_subtype) {
    fbb_.AddElement<int32_t>(HeadlineEconomicEvent::VT_EVENT_SUBTYPE, static_cast<int32_t>(event_subtype), 0);
  }
  void add_event_id(int32_t event_id) {
    fbb_.AddElement<int32_t>(HeadlineEconomicEvent::VT_EVENT_ID, event_id, 0);
  }
  void add_observation_period(::flatbuffers::Offset<::flatbuffers::String> observation_period) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_OBSERVATION_PERIOD, observation_period);
  }
  void add_release_start_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_RELEASE_START_DT, release_start_dt);
  }
  void add_release_end_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_RELEASE_END_DT, release_end_dt);
  }
  void add_value(::flatbuffers::Offset<BlpConn::FB::Value> value) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_VALUE, value);
  }
  void add_prior_value(::flatbuffers::Offset<BlpConn::FB::Value> prior_value) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_PRIOR_VALUE, prior_value);
  }
  void add_prior_event_id(int32_t prior_event_id) {
    fbb_.AddElement<int32_t>(HeadlineEconomicEvent::VT_PRIOR_EVENT_ID, prior_event_id, 0);
  }
  void add_prior_observation_period(::flatbuffers::Offset<::flatbuffers::String> prior_observation_period) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_PRIOR_OBSERVATION_PERIOD, prior_observation_period);
  }
  void add_prior_economic_release_start_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_start_dt) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_PRIOR_ECONOMIC_RELEASE_START_DT, prior_economic_release_start_dt);
  }
  void add_prior_economic_release_end_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_end_dt) {
    fbb_.AddOffset(HeadlineEconomicEvent::VT_PRIOR_ECONOMIC_RELEASE_END_DT, prior_economic_release_end_dt);
  }
  explicit HeadlineEconomicEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HeadlineEconomicEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HeadlineEconomicEvent>(end);
    fbb_.Required(o, HeadlineEconomicEvent::VT_ID_BB_GLOBAL);
    fbb_.Required(o, HeadlineEconomicEvent::VT_PARSEKYABLE_DES);
    return o;
  }
};

inline ::flatbuffers::Offset<HeadlineEconomicEvent> CreateHeadlineEconomicEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id_bb_global = 0,
    ::flatbuffers::Offset<::flatbuffers::String> parsekyable_des = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    BlpConn::FB::EventType event_type = BlpConn::FB::EventType_Unknown,
    BlpConn::FB::EventSubType event_subtype = BlpConn::FB::EventSubType_Unknown,
    int32_t event_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> observation_period = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::Value> value = 0,
    ::flatbuffers::Offset<BlpConn::FB::Value> prior_value = 0,
    int32_t prior_event_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> prior_observation_period = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_end_dt = 0) {
  HeadlineEconomicEventBuilder builder_(_fbb);
  builder_.add_prior_economic_release_end_dt(prior_economic_release_end_dt);
  builder_.add_prior_economic_release_start_dt(prior_economic_release_start_dt);
  builder_.add_prior_observation_period(prior_observation_period);
  builder_.add_prior_event_id(prior_event_id);
  builder_.add_prior_value(prior_value);
  builder_.add_value(value);
  builder_.add_release_end_dt(release_end_dt);
  builder_.add_release_start_dt(release_start_dt);
  builder_.add_observation_period(observation_period);
  builder_.add_event_id(event_id);
  builder_.add_event_subtype(event_subtype);
  builder_.add_event_type(event_type);
  builder_.add_description(description);
  builder_.add_parsekyable_des(parsekyable_des);
  builder_.add_id_bb_global(id_bb_global);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HeadlineEconomicEvent> CreateHeadlineEconomicEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id_bb_global = nullptr,
    const char *parsekyable_des = nullptr,
    const char *description = nullptr,
    BlpConn::FB::EventType event_type = BlpConn::FB::EventType_Unknown,
    BlpConn::FB::EventSubType event_subtype = BlpConn::FB::EventSubType_Unknown,
    int32_t event_id = 0,
    const char *observation_period = nullptr,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::Value> value = 0,
    ::flatbuffers::Offset<BlpConn::FB::Value> prior_value = 0,
    int32_t prior_event_id = 0,
    const char *prior_observation_period = nullptr,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> prior_economic_release_end_dt = 0) {
  auto id_bb_global__ = id_bb_global ? _fbb.CreateString(id_bb_global) : 0;
  auto parsekyable_des__ = parsekyable_des ? _fbb.CreateString(parsekyable_des) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto observation_period__ = observation_period ? _fbb.CreateString(observation_period) : 0;
  auto prior_observation_period__ = prior_observation_period ? _fbb.CreateString(prior_observation_period) : 0;
  return BlpConn::FB::CreateHeadlineEconomicEvent(
      _fbb,
      id_bb_global__,
      parsekyable_des__,
      description__,
      event_type,
      event_subtype,
      event_id,
      observation_period__,
      release_start_dt,
      release_end_dt,
      value,
      prior_value,
      prior_event_id,
      prior_observation_period__,
      prior_economic_release_start_dt,
      prior_economic_release_end_dt);
}

struct HeadlineCalendarEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeadlineCalendarEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_BB_GLOBAL = 4,
    VT_PARSEKYABLE_DES = 6,
    VT_DESCRIPTION = 8,
    VT_EVENT_TYPE = 10,
    VT_EVENT_SUBTYPE = 12,
    VT_EVENT_ID = 14,
    VT_OBSERVATION_PERIOD = 16,
    VT_RELEASE_START_DT = 18,
    VT_RELEASE_END_DT = 20,
    VT_RELEASE_STATUS = 22
  };
  const ::flatbuffers::String *id_bb_global() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_BB_GLOBAL);
  }
  const ::flatbuffers::String *parsekyable_des() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARSEKYABLE_DES);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  BlpConn::FB::EventType event_type() const {
    return static_cast<BlpConn::FB::EventType>(GetField<int32_t>(VT_EVENT_TYPE, 0));
  }
  BlpConn::FB::EventSubType event_subtype() const {
    return static_cast<BlpConn::FB::EventSubType>(GetField<int32_t>(VT_EVENT_SUBTYPE, 0));
  }
  int32_t event_id() const {
    return GetField<int32_t>(VT_EVENT_ID, 0);
  }
  const ::flatbuffers::String *observation_period() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBSERVATION_PERIOD);
  }
  const BlpConn::FB::DateTime *release_start_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_RELEASE_START_DT);
  }
  const BlpConn::FB::DateTime *release_end_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_RELEASE_END_DT);
  }
  BlpConn::FB::ReleaseStatus release_status() const {
    return static_cast<BlpConn::FB::ReleaseStatus>(GetField<int32_t>(VT_RELEASE_STATUS, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID_BB_GLOBAL) &&
           verifier.VerifyString(id_bb_global()) &&
           VerifyOffsetRequired(verifier, VT_PARSEKYABLE_DES) &&
           verifier.VerifyString(parsekyable_des()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<int32_t>(verifier, VT_EVENT_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_EVENT_SUBTYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_EVENT_ID, 4) &&
           VerifyOffset(verifier, VT_OBSERVATION_PERIOD) &&
           verifier.VerifyString(observation_period()) &&
           VerifyOffset(verifier, VT_RELEASE_START_DT) &&
           verifier.VerifyTable(release_start_dt()) &&
           VerifyOffset(verifier, VT_RELEASE_END_DT) &&
           verifier.VerifyTable(release_end_dt()) &&
           VerifyField<int32_t>(verifier, VT_RELEASE_STATUS, 4) &&
           verifier.EndTable();
  }
};

struct HeadlineCalendarEventBuilder {
  typedef HeadlineCalendarEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id_bb_global(::flatbuffers::Offset<::flatbuffers::String> id_bb_global) {
    fbb_.AddOffset(HeadlineCalendarEvent::VT_ID_BB_GLOBAL, id_bb_global);
  }
  void add_parsekyable_des(::flatbuffers::Offset<::flatbuffers::String> parsekyable_des) {
    fbb_.AddOffset(HeadlineCalendarEvent::VT_PARSEKYABLE_DES, parsekyable_des);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(HeadlineCalendarEvent::VT_DESCRIPTION, description);
  }
  void add_event_type(BlpConn::FB::EventType event_type) {
    fbb_.AddElement<int32_t>(HeadlineCalendarEvent::VT_EVENT_TYPE, static_cast<int32_t>(event_type), 0);
  }
  void add_event_subtype(BlpConn::FB::EventSubType event_subtype) {
    fbb_.AddElement<int32_t>(HeadlineCalendarEvent::VT_EVENT_SUBTYPE, static_cast<int32_t>(event_subtype), 0);
  }
  void add_event_id(int32_t event_id) {
    fbb_.AddElement<int32_t>(HeadlineCalendarEvent::VT_EVENT_ID, event_id, 0);
  }
  void add_observation_period(::flatbuffers::Offset<::flatbuffers::String> observation_period) {
    fbb_.AddOffset(HeadlineCalendarEvent::VT_OBSERVATION_PERIOD, observation_period);
  }
  void add_release_start_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt) {
    fbb_.AddOffset(HeadlineCalendarEvent::VT_RELEASE_START_DT, release_start_dt);
  }
  void add_release_end_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt) {
    fbb_.AddOffset(HeadlineCalendarEvent::VT_RELEASE_END_DT, release_end_dt);
  }
  void add_release_status(BlpConn::FB::ReleaseStatus release_status) {
    fbb_.AddElement<int32_t>(HeadlineCalendarEvent::VT_RELEASE_STATUS, static_cast<int32_t>(release_status), 0);
  }
  explicit HeadlineCalendarEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HeadlineCalendarEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HeadlineCalendarEvent>(end);
    fbb_.Required(o, HeadlineCalendarEvent::VT_ID_BB_GLOBAL);
    fbb_.Required(o, HeadlineCalendarEvent::VT_PARSEKYABLE_DES);
    return o;
  }
};

inline ::flatbuffers::Offset<HeadlineCalendarEvent> CreateHeadlineCalendarEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id_bb_global = 0,
    ::flatbuffers::Offset<::flatbuffers::String> parsekyable_des = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    BlpConn::FB::EventType event_type = BlpConn::FB::EventType_Unknown,
    BlpConn::FB::EventSubType event_subtype = BlpConn::FB::EventSubType_Unknown,
    int32_t event_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> observation_period = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt = 0,
    BlpConn::FB::ReleaseStatus release_status = BlpConn::FB::ReleaseStatus_Unknown) {
  HeadlineCalendarEventBuilder builder_(_fbb);
  builder_.add_release_status(release_status);
  builder_.add_release_end_dt(release_end_dt);
  builder_.add_release_start_dt(release_start_dt);
  builder_.add_observation_period(observation_period);
  builder_.add_event_id(event_id);
  builder_.add_event_subtype(event_subtype);
  builder_.add_event_type(event_type);
  builder_.add_description(description);
  builder_.add_parsekyable_des(parsekyable_des);
  builder_.add_id_bb_global(id_bb_global);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HeadlineCalendarEvent> CreateHeadlineCalendarEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id_bb_global = nullptr,
    const char *parsekyable_des = nullptr,
    const char *description = nullptr,
    BlpConn::FB::EventType event_type = BlpConn::FB::EventType_Unknown,
    BlpConn::FB::EventSubType event_subtype = BlpConn::FB::EventSubType_Unknown,
    int32_t event_id = 0,
    const char *observation_period = nullptr,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_start_dt = 0,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> release_end_dt = 0,
    BlpConn::FB::ReleaseStatus release_status = BlpConn::FB::ReleaseStatus_Unknown) {
  auto id_bb_global__ = id_bb_global ? _fbb.CreateString(id_bb_global) : 0;
  auto parsekyable_des__ = parsekyable_des ? _fbb.CreateString(parsekyable_des) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto observation_period__ = observation_period ? _fbb.CreateString(observation_period) : 0;
  return BlpConn::FB::CreateHeadlineCalendarEvent(
      _fbb,
      id_bb_global__,
      parsekyable_des__,
      description__,
      event_type,
      event_subtype,
      event_id,
      observation_period__,
      release_start_dt,
      release_end_dt,
      release_status);
}

struct LogMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOG_DT = 4,
    VT_MODULE_NAME = 6,
    VT_MESSAGE = 8
  };
  const BlpConn::FB::DateTime *log_dt() const {
    return GetPointer<const BlpConn::FB::DateTime *>(VT_LOG_DT);
  }
  const ::flatbuffers::String *module_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODULE_NAME);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOG_DT) &&
           verifier.VerifyTable(log_dt()) &&
           VerifyOffset(verifier, VT_MODULE_NAME) &&
           verifier.VerifyString(module_name()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct LogMessageBuilder {
  typedef LogMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_log_dt(::flatbuffers::Offset<BlpConn::FB::DateTime> log_dt) {
    fbb_.AddOffset(LogMessage::VT_LOG_DT, log_dt);
  }
  void add_module_name(::flatbuffers::Offset<::flatbuffers::String> module_name) {
    fbb_.AddOffset(LogMessage::VT_MODULE_NAME, module_name);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(LogMessage::VT_MESSAGE, message);
  }
  explicit LogMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogMessage> CreateLogMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> log_dt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> module_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  LogMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_module_name(module_name);
  builder_.add_log_dt(log_dt);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LogMessage> CreateLogMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<BlpConn::FB::DateTime> log_dt = 0,
    const char *module_name = nullptr,
    const char *message = nullptr) {
  auto module_name__ = module_name ? _fbb.CreateString(module_name) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return BlpConn::FB::CreateLogMessage(
      _fbb,
      log_dt,
      module_name__,
      message__);
}

struct Main FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MainBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  BlpConn::FB::Message message_type() const {
    return static_cast<BlpConn::FB::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const BlpConn::FB::HeadlineEconomicEvent *message_as_HeadlineEconomicEvent() const {
    return message_type() == BlpConn::FB::Message_HeadlineEconomicEvent ? static_cast<const BlpConn::FB::HeadlineEconomicEvent *>(message()) : nullptr;
  }
  const BlpConn::FB::HeadlineCalendarEvent *message_as_HeadlineCalendarEvent() const {
    return message_type() == BlpConn::FB::Message_HeadlineCalendarEvent ? static_cast<const BlpConn::FB::HeadlineCalendarEvent *>(message()) : nullptr;
  }
  const BlpConn::FB::LogMessage *message_as_LogMessage() const {
    return message_type() == BlpConn::FB::Message_LogMessage ? static_cast<const BlpConn::FB::LogMessage *>(message()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const BlpConn::FB::HeadlineEconomicEvent *Main::message_as<BlpConn::FB::HeadlineEconomicEvent>() const {
  return message_as_HeadlineEconomicEvent();
}

template<> inline const BlpConn::FB::HeadlineCalendarEvent *Main::message_as<BlpConn::FB::HeadlineCalendarEvent>() const {
  return message_as_HeadlineCalendarEvent();
}

template<> inline const BlpConn::FB::LogMessage *Main::message_as<BlpConn::FB::LogMessage>() const {
  return message_as_LogMessage();
}

struct MainBuilder {
  typedef Main Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_type(BlpConn::FB::Message message_type) {
    fbb_.AddElement<uint8_t>(Main::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(::flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Main::VT_MESSAGE, message);
  }
  explicit MainBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Main> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Main>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Main> CreateMain(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    BlpConn::FB::Message message_type = BlpConn::FB::Message_NONE,
    ::flatbuffers::Offset<void> message = 0) {
  MainBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_HeadlineEconomicEvent: {
      auto ptr = reinterpret_cast<const BlpConn::FB::HeadlineEconomicEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_HeadlineCalendarEvent: {
      auto ptr = reinterpret_cast<const BlpConn::FB::HeadlineCalendarEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_LogMessage: {
      auto ptr = reinterpret_cast<const BlpConn::FB::LogMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace FB
}  // namespace BlpConn

#endif  // FLATBUFFERS_GENERATED_BLPCONNFB_BLPCONN_FB_H_
